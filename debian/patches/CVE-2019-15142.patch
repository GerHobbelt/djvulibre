Index: djvulibre-3.5.27.1/libdjvu/DjVmDir.cpp
===================================================================
--- djvulibre-3.5.27.1.orig/libdjvu/DjVmDir.cpp
+++ djvulibre-3.5.27.1/libdjvu/DjVmDir.cpp
@@ -299,36 +299,44 @@ DjVmDir::decode(const GP<ByteStream> &gs
          memcpy((char*) strings+strings_size, buffer, length);
       }
       DEBUG_MSG("size of decompressed names block=" << strings.size() << "\n");
-   
-         // Copy names into the files
+  
+      int strings_size=strings.size();
+      strings.resize(strings_size+3);
+      memset((char*) strings+strings_size, 0, 4);
+ 
+      // Copy names into the files
       const char * ptr=strings;
       for(pos=files_list;pos;++pos)
       {
          GP<File> file=files_list[pos];
-
+         if (ptr >= (const char*)strings + strings_size)
+           G_THROW( "DjVu document is corrupted (DjVmDir)" );
          file->id=ptr;
          ptr+=file->id.length()+1;
          if (file->flags & File::HAS_NAME)
          {
             file->name=ptr;
             ptr+=file->name.length()+1;
-         } else
+         }
+	 else
          {
             file->name=file->id;
          }
          if (file->flags & File::HAS_TITLE)
          {
             file->title=ptr;
-       ptr+=file->title.length()+1;
-         } else
-       file->title=file->id;
-   /* msr debug:  multipage file, file->title is null.  
+            ptr+=file->title.length()+1;
+         }
+	 else {
+          file->title=file->id;
+	 }
+	 /* msr debug:  multipage file, file->title is null.  
          DEBUG_MSG(file->name << ", " << file->id << ", " << file->title << ", " <<
                    file->offset << ", " << file->size << ", " <<
                    file->is_page() << "\n"); */
       }
 
-         // Check that there is only one file with SHARED_ANNO flag on
+      // Check that there is only one file with SHARED_ANNO flag on
       int shared_anno_cnt=0;
       for(pos=files_list;pos;++pos)
       {
